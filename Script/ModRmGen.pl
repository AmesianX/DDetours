# Author: Mahdi Safsafi
# https://github.com/MahdiSafsafi/delphi-detours-library

no warnings 'experimental::smartmatch';

sub gen($) {
	my $mod16 = shift;
	my $name = $mod16 ? 'ModRmFlags16':'ModRmFlags32';
	my @modrm;
	for ( my $i = 0 ; $i < 0xff + 1 ; $i++ ) {
		my @flags;
		push( @flags, ( $i >= 0xc0 ) ? 'MF_REG' : 'MF_MEM' );
		push( @flags, 'MF_SIB' )
		  if ( ( !$mod16 )
			&& ( ( $i & 0x07 ) == 0x04 )
			&& ( ( $i & 0xc0 ) != 0xc0 ) );
		if ( $mod16 && ( ( $i & 0xc0 ) == 00 ) && ( ( $i & 0x07 ) == 0x06 ) )
		{
			push( @flags, 'MF_DISP_ONLY' );
			push( @flags, 'MF_SWORD' );
		}

		if (   ( !$mod16 )
			&& ( $i ~~ [ 0x05, 0x0d, 0x15, 0x1d, 0x25, 0x2d, 0x35, 0x3d ] ) )
		{
			push( @flags, 'MF_SDWORD' );
			push( @flags, 'MF_DISP_ONLY' );
		}
		elsif ( $i >= 0x40 && $i <= 0x7f ) {
			push( @flags, 'MF_SBYTE' );
		}
		elsif ( $i >= 0x80 && $i <= 0xbf ) {
			push( @flags, $mod16 ? 'MF_SWORD' : 'MF_SDWORD' );
		}

		my $sflags = sprintf "    %s { 0x%.2X }", join( ' or ', @flags ), $i;
		push( @modrm, $sflags );
	}

	my $smodrm = join( ",\n", @modrm );
    $smodrm =~s/(\{.+?\}),/,$1/g;
    $smodrm =~s/\s+,/, /g;
    $smodrm =~s/,\s+/, /g;
    print F "  $name: TModRmFlagsArray = (//\n";
	print F "$smodrm);\n\n";

}

open (F,'>ModRmFlags.Inc');
print F"\n// https://github.com/MahdiSafsafi/delphi-detours-library\n";
print F"// Auto generated by '$0' => Do not edit ! \n\n";
my $cnst = << '__@__';
type
  TModRmFlagsArray = array [Byte] of Byte;
  PModRmFlagsArray = ^TModRmFlagsArray;
  
const
  { ModRm flags }
  MF_MEM = $01;
  MF_REG = $02;
  MF_SIB = $04;
  MF_SBYTE = $08;
  MF_SWORD = $10;
  MF_SDWORD = $20;
  MF_DISP_ONLY = $40;
  MF_REL = $80;
  
__@__

print F $cnst;
gen(0);
gen(1);

close (F);

print "Done.\n";